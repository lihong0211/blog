# [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

> 原题链接：[LeetCode 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)








## 题目描述

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历 **。

 

示例 1：

输入：root = `[1,null,2,3]`

输出：`[3,2,1]`

- **解释：** 示例 2：

输入：root = `[1,2,3,4,5,null,8,null,null,6,7,9]`

输出：`[4,6,7,5,2,9,8,3,1]`

- **解释：** 示例 3：

输入：root = `[]`

输出：`[]`

示例 4：

输入：root = `[1]`

输出：`[1]`

 

**提示：**

- 树中节点的数目在范围 `[0, 100]` 内

- `-100 <= Node.val <= 100`

 

**进阶：**递归算法很简单，你可以通过迭代算法完成吗？

**难度：** Easy

---

## 题解代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
// const postorderTraversal = (root, arr = []) => {
//     if (root) {
//         postorderTraversal(root.left, arr)
//         postorderTraversal(root.right, arr)
//         arr.push(root.val)
//     }
//     return arr
// };
const postorderTraversal = (root) => {
    if (!root) return []
    const ret = []
    const stack = []
    let cur = root
    while(cur || stack.length) {
        while(cur) {
            stack.push(cur)
            cur = cur.left
        }
        cur = stack.pop()
        if (cur.right && cur.r !== cur.right) {
            // 打一个标记 下次再遇到他的时候直接访问它的值并再次出栈
            cur.r = cur.right
            stack.push(cur)
            cur = cur.right
        } else {
            ret.push(cur.val)
            cur = null
        }
    }
    return ret
}
```
