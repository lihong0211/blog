# [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

> 原题链接：[LeetCode 10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)








## 题目描述

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符

- `'*'` 匹配零个或多个前面的那一个元素

返回一个布尔值，表示匹配是否覆盖整个输入字符串（而非部分）。

 

**示例 1：**

- **输入：** s = "aa", p = "a"
- **输出：** false
- **解释：** "a" 无法匹配 "aa" 整个字符串。

**示例 2:**

- **输入：** s = "aa", p = "a*"
- **输出：** true
- **解释：** 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

**示例 3：**

- **输入：** s = "ab", p = ".*"
- **输出：** true
- **解释：** ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

 

**提示：**

- `1 <= s.length <= 20`

- `1 <= p.length <= 20`

- `s` 只包含从 `a-z` 的小写字母。

- `p` 只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

- 保证每次出现字符 `*` 时，前面都匹配到有效的字符

**难度：** Hard

---

## 题解代码

```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
const isMatch = (s, p) => {
    // 边界情况，如果 s 和 p 都为空，说明处理结束了，返回true，否则返回false 
    if (p.length <=0) {
        return !s.length
    }
    // 判断 p 模式字符串都第一个字符和 s 字符串都第一个字符是不是匹配
    let match = false

    if (s.length > 0 && (p[0] === s[0] || p[0] === '.')) {
        match = true
    }
    // p 有模式的
    if (p.length > 1 && p[1] === '*' ) {
        // 第一种情况--匹配0个字符，砍掉p的前2位继续验证
        // 第二种情况--匹配一个字符，砍掉s的第一位继续验证
        // 这两种情况有一种返回true，说明匹配成功
        return isMatch(s, p.slice(2)) || (match && isMatch(s.slice(1), p))
    } else {
        return match && isMatch(s.slice(1), p.slice(1))
    }
};
```
