# [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

> 原题链接：[LeetCode 1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)








## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums`[i]`` 替换为 `-nums`[i]`` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

 

**示例 1：**

- **输入：** nums = `[4,2,3]`, k = 1
- **输出：** 5
- **解释：** 选择下标 1 ，nums 变为 `[4,-2,3]` 。

**示例 2：**

- **输入：** nums = `[3,-1,0,2]`, k = 3
- **输出：** 6
- **解释：** 选择下标 (1, 2, 2) ，nums 变为 `[3,1,0,2]` 。

**示例 3：**

- **输入：** nums = `[2,-3,-1,5,-4]`, k = 2
- **输出：** 13
- **解释：** 选择下标 (1, 4) ，nums 变为 `[2,3,-1,5,4]` 。

 

**提示：**

- 1 <= nums.length <= 104
- `-100 <= nums`[i]` <= 100`

- 1 <= k <= 104

**难度：** Easy

---

## 题解代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var largestSumAfterKNegations = function(nums, k) {
  nums.sort((m, n) => m - n)
  for(let i = 0; i < k; i++) {
    nums[0] = -nums[0]
    bubble(nums)
  }
  return total(nums)
};

function bubble (nums) {
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] < nums[0]) {
      const temp = nums[i]
      nums[i] = nums[0]
      nums[0] = temp
      break
    }
  }
}

function total(nums) {
  return nums.reduce((res, cur) => {
    return res + cur
  }, 0)
}
```
