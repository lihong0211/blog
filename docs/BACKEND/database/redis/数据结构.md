Redis 的数据结构可以分为两个层面：

1. **对外暴露的数据类型**：即开发者通过 API 直接操作的数据形式。
2. **底层实现的数据结构**：为了在内存和性能上达到最优，每种数据类型在不同条件下，内部采用不同的编码方式实现。

---

### 一、 对外数据模型（数据类型）

这是 Redis 面向用户提供的 5 种核心数据类型。

#### 1. **String（字符串）**

- **描述**：最简单的类型，是二进制安全的，意味着可以存储任何数据，如图片、序列化对象等。一个键最大能存储 512MB。
- **常用命令**：`SET`, `GET`, `INCR`, `DECR`, `APPEND`, `STRLEN`, `MSET`, `MGET`
- **应用场景**：
  - **缓存**：存储会话、HTML 片段、对象等。
  - **计数器**：利用 `INCR`/`DECR` 实现文章阅读量、点赞数。
  - **分布式锁**：利用 `SET key value NX EX` 实现。
  - **位操作**：支持 `SETBIT`, `GETBIT`, `BITCOUNT`，用于实现位图功能，如用户签到、活跃用户统计。

#### 2. **List（列表）**

- **描述**：按插入顺序排序的字符串元素集合。是**双向链表**，支持在两端高效插入和删除。
- **常用命令**：`LPUSH`/`RPUSH`, `LPOP`/`RPOP`, `LRANGE`, `LLEN`, `BLPOP`/`BRPOP`（阻塞版本）
- **应用场景**：
  - **消息队列**：利用 `LPUSH`（生产）和 `BRPOP`（阻塞消费）实现简单的 FIFO 队列或栈。
  - **最新列表**：如朋友圈动态、新闻推送，`LTRIM` 可以限制列表长度。
  - **记录操作历史**。

#### 3. **Hash（哈希表/字典）**

- **描述**：是 field-value 的映射表，非常适合存储对象。
- **常用命令**：`HSET`, `HGET`, `HMSET`, `HMGET`, `HGETALL`, `HINCRBY`, `HKEYS`, `HVALS`
- **应用场景**：
  - **存储对象**：如用户信息（`user:1` -> `{name: "Alice", age: 30}`）。与将对象序列化为 JSON 字符串相比，Hash 可以单独读写某个字段，更节省网络流量。
  - **购物车**：`key` 为用户ID，`field` 为商品ID，`value` 为数量。

#### 4. **Set（集合）**

- **描述**：无序的、不重复的字符串集合。支持高效的集合运算。
- **常用命令**：`SADD`, `SMEMBERS`, `SISMEMBER`, `SINTER`（交集）, `SUNION`（并集）, `SDIFF`（差集）, `SPOP`（随机弹出）
- **应用场景**：
  - **标签系统**：给文章/用户打标签，`SADD` 添加标签。
  - **共同好友/兴趣**：利用 `SINTER` 计算交集。
  - **抽奖/随机推荐**：利用 `SRANDMEMBER` 或 `SPOP`。
  - **数据去重**。

#### 5. **Sorted Set（有序集合）**

- **描述**：与 Set 类似，但每个元素都会关联一个 `double` 类型的分数（score）。元素按分数从小到大排序，分数可重复，但成员唯一。**Redis 最强大的数据结构之一**。
- **常用命令**：`ZADD`, `ZRANGE`/`ZREVRANGE`（按排名查询）, `ZRANGEBYSCORE`（按分数查询）, `ZRANK`/`ZREVRANK`（获取排名）, `ZINCRBY`, `ZREM`
- **应用场景**：
  - **排行榜**：如游戏积分榜、热搜榜。
  - **带权重的队列**：分数作为优先级。
  - **时间线**：将时间戳作为分数，存储按时间排序的事件。
  - **范围查找**：如查找价格在 100-200 之间的商品。

#### 6. **额外的扩展类型（由基本类型封装）**

- **Bitmap（位图）**：本质是 String，通过位操作实现。用于超大规模布尔值统计（如日活）。
- **HyperLogLog**：用于**基数估算**（不精确的去重计数），占用空间极小（12KB），误差率约 0.81%。
- **GEO**：基于 Sorted Set 实现的地理位置信息存储与查询（计算距离、附近的人等）。
- **Stream**：Redis 5.0 引入，用于实现更可靠的消息队列，支持多消费者组、消息回溯。

---

### 二、 底层实现（编码）

Redis 使用一个全局的 **哈希表**（`dictht`）来保存所有的键值对。这个“键”就是用户设置的字符串 key，而这个“值”则指向一个 `redisObject` 结构体。

`redisObject` 是理解 Redis 多态性的关键，它包含三个核心属性：

- `type`: 标识**对外数据类型**（String, List, Hash, Set, ZSet）。
- `encoding`: 标识该数据在**底层实际使用的数据结构**。
- `ptr`: 指向具体数据的指针。

#### 核心底层数据结构

1. **SDS（Simple Dynamic String，简单动态字符串）**

   - **所有键**都是 SDS。
   - **String 类型的值**，当它是数字或短字符串时，也常以 SDS 形式存储。
   - **特点**：二进制安全、预分配内存、惰性释放、常数时间获取长度。
2. **Int**

   - 当 String 类型的值可以表示为长整型时，Redis 会直接将其存储为 `long` 类型，以节省空间并提升运算速度。
3. **Dict（字典/哈希表）**

   - **Hash 类型**的底层实现之一，也是 Redis 全局键空间的核心实现。
   - 采用经典的哈希表结构，使用链地址法解决哈希冲突，并包含渐进式 rehash 机制。
4. **ZipList（压缩列表）**

   - 一块连续的内存，顺序存储元素。目的是在元素较少、体积较小时，**节省内存**。
   - **应用**：早期是 List、Hash、Sorted Set 在小数据量时的默认编码。现已逐步被 `listpack` 替代。
5. **ListPack（紧凑列表，Redis 7.0+）**

   - Redis 7.0 用于取代 `ziplist` 的新结构。设计更简单，完全避免了级联更新问题，提升了性能。
   - **应用**：List、Hash、Sorted Set 在小数据量时的默认编码。
6. **QuickList（快速列表，Redis 3.2+）**

   - **List 类型**的主要底层实现。是 `ZipList`/`ListPack` 的**双向链表**。它将多个 `ZipList`/`ListPack` 节点用指针连接起来。
   - **目的**：在空间效率和操作性能（特别是两端的 `push/pop`）之间取得平衡。
7. **SkipList（跳跃表）**

   - **Sorted Set 类型**的主要底层实现之一（当元素多或成员较长时）。
   - 一种有序数据结构，通过维护多级索引来实现平均 O(log N) 复杂度的节点查找，同时支持范围操作。
8. **IntSet（整数集合）**

   - **Set 类型**的底层实现之一，当集合中所有元素都是整数且数量较少时使用。
   - 是一块连续内存，有序地存储整数，支持升级机制（如从 int16 升级到 int32）。

### 三、 数据类型与底层编码的对应关系

你可以通过 `OBJECT ENCODING key` 命令查看一个 key 当前使用的底层编码。

| 数据类型             | 可能的底层编码（Redis 7.0 典型）                                          | 触发条件（大致）                                    |
| :------------------- | :------------------------------------------------------------------------ | :-------------------------------------------------- |
| **String**     | `int` `<br>` `embstr`（嵌入式的 SDS）`<br>` `raw`（普通的 SDS） | 整数值`<br>`短字符串（<= 44字节）`<br>`长字符串 |
| **List**       | `quicklist`                                                             | （全部）                                            |
| **Hash**       | `listpack` `<br>` `hashtable`                                       | field-value 对少且值小`<br>` 数据量大或值大时转换 |
| **Set**        | `intset` `<br>` `hashtable`                                         | 元素全是整数且数量少`<br>` 包含非整数或数量多时   |
| **Sorted Set** | `listpack` `<br>` `skiplist` + `dict`（组合结构）                 | 元素少且值小`<br>` 数据量大时转换                 |

**总结**：

Redis 的魅力在于这种**双层设计**：

- **上层**：为开发者提供了直观、实用的数据类型，简化了业务建模。
- **下层**：根据数据的特点（大小、类型、数量），智能地切换最节省内存或最高效的底层数据结构，并在条件变化时自动转换。

这种设计使得开发者无需关心底层优化细节，就能获得接近手写定制数据结构般的性能。这也是 Redis 在性能、内存效率和功能灵活性上能够取得绝佳平衡的根本原因。
