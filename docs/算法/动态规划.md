# 动态规划

动态规划（Dynamic Programming，DP）是一种通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法。

## 核心思想

1. **最优子结构**：问题的最优解包含子问题的最优解
2. **重叠子问题**：子问题会被重复计算
3. **状态转移方程**：描述问题状态之间的转换关系

## 解题步骤

1. 定义状态（dp 数组的含义）
2. 找出状态转移方程
3. 确定初始状态和边界条件
4. 确定计算顺序（避免重复计算）

## 经典例题

### 1. 斐波那契数列

最简单的动态规划问题。

```python
def fibonacci(n):
    if n <= 1:
        return n
    
    # dp[i] 表示第 i 个斐波那契数
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# 空间优化版本
def fibonacci_optimized(n):
    if n <= 1:
        return n
    
    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    
    return curr
```

### 2. 爬楼梯问题

假设你正在爬楼梯，需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶，有多少种不同的方法可以爬到楼顶？

```python
def climb_stairs(n):
    if n <= 2:
        return n
    
    # dp[i] 表示爬到第 i 阶的方法数
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    
    for i in range(3, n + 1):
        # 可以从 i-1 爬1阶，或从 i-2 爬2阶
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

### 3. 背包问题

#### 0-1 背包

给定 n 个物品，每个物品有重量和价值，在限定的总重量内，选择若干物品使得总价值最大。

```python
def knapsack_01(weights, values, capacity):
    n = len(weights)
    # dp[i][j] 表示前 i 个物品，容量为 j 时的最大价值
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(capacity + 1):
            # 不选第 i 个物品
            dp[i][j] = dp[i-1][j]
            
            # 如果能选第 i 个物品
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], 
                              dp[i-1][j-weights[i-1]] + values[i-1])
    
    return dp[n][capacity]
```

### 4. 最长公共子序列（LCS）

给定两个字符串，找出它们的最长公共子序列。

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    # dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的 LCS 长度
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

### 5. 最长递增子序列（LIS）

给定一个整数数组，找到其中最长严格递增子序列的长度。

```python
def length_of_lis(nums):
    if not nums:
        return 0
    
    n = len(nums)
    # dp[i] 表示以 nums[i] 结尾的最长递增子序列长度
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

## 优化技巧

1. **空间优化**：观察状态转移方程，如果只依赖前几个状态，可以用滚动数组
2. **时间优化**：
   - 使用记忆化搜索（自顶向下）
   - 优化状态定义减少维度
   - 单调队列/单调栈优化

## 常见 DP 类型

- **线性 DP**：最长递增子序列、最大子数组和
- **区间 DP**：矩阵连乘、石子合并
- **背包 DP**：0-1 背包、完全背包
- **树形 DP**：树的直径、打家劫舍 III
- **状态压缩 DP**：旅行商问题、棋盘覆盖
