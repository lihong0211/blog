# 二分查找

二分查找（Binary Search）是一种在有序数组中查找特定元素的高效算法。

## 基本思想

在有序数组中，通过比较中间元素与目标值：
- 如果相等，返回中间位置
- 如果目标值小，在左半部分继续查找
- 如果目标值大，在右半部分继续查找

**时间复杂度**：O(log n)

## 基本模板

### 标准二分查找

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # 避免溢出
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  # 未找到
```

### 查找左边界

查找第一个等于目标值的位置。

```python
def binary_search_left(arr, target):
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # 收缩右边界
    
    # 检查是否找到
    if left < len(arr) and arr[left] == target:
        return left
    return -1
```

### 查找右边界

查找最后一个等于目标值的位置。

```python
def binary_search_right(arr, target):
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] <= target:
            left = mid + 1  # 收缩左边界
        else:
            right = mid
    
    # 检查是否找到
    if left > 0 and arr[left - 1] == target:
        return left - 1
    return -1
```

## 变体问题

### 1. 在旋转排序数组中查找

```python
def search_rotated(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if nums[mid] == target:
            return mid
        
        # 判断哪一半是有序的
        if nums[left] <= nums[mid]:  # 左半部分有序
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # 右半部分有序
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

### 2. 寻找峰值

峰值元素是指其值大于左右相邻值的元素。

```python
def find_peak_element(nums):
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        if nums[mid] < nums[mid + 1]:
            left = mid + 1  # 峰值在右侧
        else:
            right = mid  # 峰值在左侧或就是 mid
    
    return left
```

### 3. 寻找最小值（旋转数组）

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        if nums[mid] > nums[right]:
            # 最小值在右半部分
            left = mid + 1
        else:
            # 最小值在左半部分（包括 mid）
            right = mid
    
    return nums[left]
```

## 应用场景

### 1. 在二维矩阵中查找

```python
def search_matrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    
    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        # 将一维索引转换为二维坐标
        mid_val = matrix[mid // n][mid % n]
        
        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False
```

### 2. 求平方根

```python
def my_sqrt(x):
    if x < 2:
        return x
    
    left, right = 1, x // 2
    
    while left <= right:
        mid = left + (right - left) // 2
        square = mid * mid
        
        if square == x:
            return mid
        elif square < x:
            left = mid + 1
        else:
            right = mid - 1
    
    return right  # 返回整数部分
```

## 注意事项

1. **边界条件**：`left <= right` 还是 `left < right`
2. **溢出问题**：使用 `left + (right - left) // 2` 而不是 `(left + right) // 2`
3. **更新条件**：`left = mid + 1` 还是 `left = mid`
4. **返回值**：返回索引还是元素值，是否找到的判断

## 二分答案

当问题满足"单调性"时，可以用二分查找答案。

```python
def min_eating_speed(piles, h):
    """
    珂珂吃香蕉问题：找到最小的吃香蕉速度
    """
    def can_finish(speed):
        hours = sum((pile + speed - 1) // speed for pile in piles)
        return hours <= h
    
    left, right = 1, max(piles)
    
    while left < right:
        mid = left + (right - left) // 2
        if can_finish(mid):
            right = mid  # 可以更慢
        else:
            left = mid + 1  # 需要更快
    
    return left
```
