# [786. 第 K 个最小的素数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)

> 原题链接：[LeetCode 786. 第 K 个最小的素数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)




## 题目描述

给你一个按递增顺序排序的数组 `arr` 和一个整数 `k` 。数组 `arr` 由 `1` 和若干 **质数** 组成，且其中所有整数互不相同。

对于每对满足 `0 <= i < j < arr.length` 的 `i` 和 `j` ，可以得到分数 `arr[i] / arr[j]` 。

那么第 `k` 个最小的分数是多少呢?  以长度为 `2` 的整数数组返回你的答案, 这里 `answer[0] == arr[i]` 且 `answer[1] == arr[j]` 。

 

**示例 1：**

**输入：**arr = [1,2,3,5], k = 3
**输出：**[2,5]
**解释：**已构造好的分数,排序后如下所示: 
1/5, 1/3, 2/5, 1/2, 3/5, 2/3
很明显第三个最小的分数是 2/5

**示例 2：**

**输入：**arr = [1,7], k = 1
**输出：**[1,7]

 

**提示：**

	- `2 <= arr.length <= 1000`

	1 <= arr[i] <= 3 * 104
	- `arr[0] == 1`

	- `arr[i]` 是一个 **质数** ，`i > 0`

	- `arr` 中的所有数字 **互不相同** ，且按 **严格递增** 排序

	- `1 <= k <= arr.length * (arr.length - 1) / 2`

 

**进阶：**你可以设计并实现时间复杂度小于 O(n2) 的算法解决此问题吗？

**难度：** Medium

---

## 题解代码

```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var kthSmallestPrimeFraction = function(arr, k) {
  const pq = new MinPriorityQueue({ 
    compare: (a, b) => arr[a[0]] * arr[b[1]] - arr[b[0]] * arr[a[1]]
  });

  const len = arr.length
  for (let i = 0; i < len; i++) {
    pq.enqueue([0, i])
  }

  while (k-- >= 0 && pq.size()) {
    const [i, j] = pq.dequeue();
    if (!k) return [arr[i], arr[j]]
    // 下一个备选：分母不变的情况下分子变大-->i++
    if (i + 1 < j) pq.enqueue([i + 1, j]);
  }
};
```
