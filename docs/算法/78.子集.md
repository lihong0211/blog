# [78. 子集](https://leetcode.cn/problems/subsets/)

> 原题链接：[LeetCode 78. 子集](https://leetcode.cn/problems/subsets/)




## 题目描述

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

**输入：**nums = [1,2,3]
**输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

**示例 2：**

**输入：**nums = [0]
**输出：**[[],[0]]

 

**提示：**

	- `1 <= nums.length <= 10`

	- `-10 <= nums[i] <= 10`

	- `nums` 中的所有元素 **互不相同**

**难度：** Medium

---

## 题解代码

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */

// const test = nums => {
//     const uninclude = (arr, it) => {
//         return !arr.find(item => item.sort((m, n) => n - m).join() === [].concat([...it]).sort((m, n) => n - m).join())
//     }

//     const backtrack = (list, temp, nums) => {
//         if (uninclude(list, temp)) {
//             list.push([...temp])
//             if (temp.length === nums.length) return
//         }
//         for (let i = 0; i < nums.length; i++) {
//             if (temp.includes(nums[i])) continue
//             temp.push(nums[i])
//             backtrack(list, temp, nums)
//             temp.pop()
//         }
//     }
    
//     const list = []
//     backtrack(list, [], nums)
//     console.log(list)
//     return list
// }
// TODO:浏览器算到8位就已经卡死

var subsets = function (nums) {
    const ret = []
    backTrack(nums, [], ret, 0)
    return ret
}

function backTrack (nums, path, ret, start) {
    if (start > nums.length) return
    ret.push([...path])
    for (let i = start; i < nums.length; i++) {
        path.push(nums[i])
        backTrack(nums, [...path], ret, i + 1)
        path.pop()
    }
}
```
